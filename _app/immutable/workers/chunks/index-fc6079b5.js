var S=Object.defineProperty;var M=(r,t,e)=>t in r?S(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var o=(r,t,e)=>(M(r,typeof t!="symbol"?t+"":t,e),e);function d(r,...t){const e={};for(let s of t)e[s]=(r[s]||(()=>0)).bind(r);return e}class g extends Error{constructor(e){super(`process exited with code ${e}.`);o(this,"code");this.code=e}}class y extends Error{constructor(t,e){super(`${t}.${e} not implemented.`)}}class $ extends Error{constructor(t="abort"){super(t)}}class U extends Error{constructor(t){super(t)}}function f(r){if(!r)throw new U("assertion failed.")}const x=r=>r;async function A(r){{const t=await fetch(x(r));return WebAssembly.compile(await t.arrayBuffer())}}function C(r,t){return WebAssembly.instantiate(r,t)}const E=r=>fetch(x(r)).then(t=>t.arrayBuffer()),z=r=>r+"/clang/bin/memfs",F=r=>r+"/clang/bin/clang",B=r=>r+"/clang/bin/lld",p=r=>r+"/clang/bin/sysroot.tar",b=0;class N{constructor(t){o(this,"ready");o(this,"mem",null);o(this,"hostMem_",null);o(this,"stdinStr");o(this,"stdin");o(this,"stdout");o(this,"instance",null);o(this,"exports");o(this,"out",!0);this.stdin=t.stdin,this.stdout=t.stdout,this.stdinStr=t.stdinStr||"";const e=d(this,"abort","host_write","host_read","memfs_log","copy_in","copy_out");this.ready=A(z(t.path)).then(s=>WebAssembly.instantiate(s,{env:e})).then(s=>{this.instance=s,this.exports=s.exports,this.mem=new k(this.exports.memory),this.exports.init()})}set hostMem(t){this.hostMem_=t}setStdinStr(t){this.stdinStr=t}addDirectory(t){this.mem.check(),this.mem.write(this.exports.GetPathBuf(),t),this.exports.AddDirectoryNode(t.length)}addFile(t,e){const s=e instanceof ArrayBuffer?e.byteLength:e.length;this.mem.check(),this.mem.write(this.exports.GetPathBuf(),t);const i=this.exports.AddFileNode(t.length,s),n=this.exports.GetFileNodeAddress(i);this.mem.check(),this.mem.write(n,e)}getFileContents(t){this.mem.check(),this.mem.write(this.exports.GetPathBuf(),t);const e=this.exports.FindNode(t.length),s=this.exports.GetFileNodeAddress(e),i=this.exports.GetFileNodeSize(e);return new Uint8Array(this.mem.buffer,s,i)}abort(){throw new $}host_write(t,e,s,i){this.hostMem_.check(),f(t<=2);let n=0,h="";for(let a=0;a<s;++a){const m=this.hostMem_.read32(e);e+=4;const c=this.hostMem_.read32(e);e+=4,h+=this.hostMem_.readStr(m,c),n+=c}return this.hostMem_.write32(i,n),this.out&&this.stdout(h),b}host_read(t,e,s,i){this.hostMem_.check(),f(t===0);let n=0;for(let h=0;h<s;++h){const a=this.hostMem_.read32(e);e+=4;const m=this.hostMem_.read32(e);e+=4,this.stdinStr.length||(this.stdinStr=this.stdin());const c=Math.min(m,this.stdinStr.length);if(c===0||(this.hostMem_.write(a,this.stdinStr.substring(0,c)),this.stdinStr=this.stdinStr.substring(c),n+=c,c!==m))break}return this.hostMem_.write32(i,n),b}memfs_log(t,e){this.mem.check(),console.log(this.mem.readStr(t,e))}copy_out(t,e,s){this.hostMem_.check();const i=new Uint8Array(this.hostMem_.buffer,t,s);this.mem.check();const n=new Uint8Array(this.mem.buffer,e,s);i.set(n)}copy_in(t,e,s){this.mem.check();const i=new Uint8Array(this.mem.buffer,t,s);this.hostMem_.check();const n=new Uint8Array(this.hostMem_.buffer,e,s);i.set(n)}}function w(r,t,e=-1){const s=e===-1?r.length:t+e;let i="";for(let n=t;n<s&&r[n];++n)i+=String.fromCharCode(r[n]);return i}function L(r,t,e){return parseInt(w(r,t,e),8)}class k{constructor(t){o(this,"memory");o(this,"buffer");o(this,"u8");o(this,"u32");this.memory=t,this.buffer=t.buffer,this.u8=new Uint8Array(this.buffer),this.u32=new Uint32Array(this.buffer)}check(){this.buffer.byteLength===0&&(this.buffer=this.memory.buffer,this.u8=new Uint8Array(this.buffer),this.u32=new Uint32Array(this.buffer))}read8(t){return this.u8[t]}read32(t){return this.u32[t>>2]}readStr(t,e){return w(this.u8,t,e)}write8(t,e){this.u8[t]=e}write32(t,e){this.u32[t>>2]=e}write64(t,e,s=0){this.write32(t,e),this.write32(t+4,s)}writeStr(t,e){return t+=this.write(t,e),this.write8(t,0),e.length+1}writeUint8(t,e){return new Uint8Array(this.buffer,t,e.length).set(e),e.length}write(t,e){return e instanceof ArrayBuffer?this.writeUint8(t,new Uint8Array(e)):typeof e=="string"?this.writeUint8(t,e.split("").map(s=>s.charCodeAt(0))):this.writeUint8(t,e)}}function*D(r){const t=new Uint8Array(r);let e=0;const s=h=>(e+=h,w(t,e-h,h)),i=h=>(e+=h,L(t,e-h,h)),n=()=>e=e+511&-512;for(;e+512<=t.length;){const h={filename:s(100),mode:i(8),owner:i(8),group:i(8),size:i(12),mtime:i(12),checksum:i(8),type:s(1),linkname:s(100),ustar:s(8)};if(!h.ustar)return;const a={...h,ownerName:s(32),groupName:s(32),devMajor:s(8),devMinor:s(8),filenamePrefix:s(155)};n(),a.type==="0"&&(a.contents=t.subarray(e,e+a.size),e+=a.size,n()),yield a}}function j(r,t){for(const e of D(r))switch(e.type){case"0":t.addFile(e.filename,e.contents);break;case"5":t.addDirectory(e.filename);break;default:console.log("type",e.type),f(!1)}}const l=0,v=789514;class O{constructor(t,e,s,...i){o(this,"ready");o(this,"mem",null);o(this,"memfs");o(this,"instance",null);o(this,"exports");o(this,"argv");o(this,"environ");o(this,"handles",new Map);o(this,"nextHandle",0);this.argv=[s,...i],this.environ={USER:"jungol"},this.memfs=e;const n=d(this),h={...d(this,"proc_exit","environ_sizes_get","environ_get","args_sizes_get","args_get","random_get","clock_time_get","poll_oneoff"),...this.memfs.exports};this.ready=C(t,{wasi_unstable:h,env:n}).then(a=>{this.instance=a,this.exports=this.instance.exports,this.mem=new k(this.exports.memory),this.memfs.hostMem=this.mem})}async run(){await this.ready;try{this.exports._start()}catch(t){let e=!0;if(t instanceof g){if(t.code===v)return console.log("Allowing rAF after exit."),!0;if(console.log(`Disallowing rAF since exit code is ${t.code}.`),t.code==0)return!1;e=!1}let s=`\x1B[91mError: ${t.message}`;throw e&&(s=s+`
${t.stack}`),s+=`\x1B[0m
`,this.memfs.stdout(s),t}}proc_exit(t){throw new g(t)}environ_sizes_get(t,e){this.mem.check();let s=0;const i=Object.getOwnPropertyNames(this.environ);for(const n of i){const h=this.environ[n];s+=n.length+h.length+2}return this.mem.write64(t,i.length),this.mem.write64(e,s),l}environ_get(t,e){this.mem.check();const s=Object.getOwnPropertyNames(this.environ);for(const i of s)this.mem.write32(t,e),t+=4,e+=this.mem.writeStr(e,`${i}=${this.environ[i]}`);return this.mem.write32(t,0),l}args_sizes_get(t,e){this.mem.check();let s=0;for(let i of this.argv)s+=i.length+1;return this.mem.write64(t,this.argv.length),this.mem.write64(e,s),l}args_get(t,e){this.mem.check();for(let s of this.argv)this.mem.write32(t,e),t+=4,e+=this.mem.writeStr(e,s);return this.mem.write32(t,0),l}random_get(t,e){const s=new Uint8Array(this.mem.buffer,t,e);for(let i=0;i<e;++i)s[i]=Math.random()*256|0}clock_time_get(){throw new y("wasi_unstable","clock_time_get")}poll_oneoff(){throw new y("wasi_unstable","poll_oneoff")}}const _="\x1B[92m",u="\x1B[0m",P="\x1B[1;93m",T=["-disable-free","-isysroot","/","-internal-isystem","/include/c++/v1","-internal-isystem","/include","-internal-isystem","/lib/clang/8.0.1/include","-ferror-limit","19","-fmessage-length","80","-fcolor-diagnostics"];class I{constructor(t){o(this,"ready");o(this,"memfs");o(this,"stdout");o(this,"moduleCache");o(this,"showTiming");o(this,"log");o(this,"lastCode","");o(this,"path");this.moduleCache={},this.stdout=t.stdout,this.showTiming=t.showTiming||!1,this.log=t.log||!1,this.path=t.path,this.memfs=new N({stdout:this.stdout,stdin:t.stdin,path:this.path}),this.ready=this.memfs.ready.then(()=>this.hostLogAsync(`Untarring ${p(this.path)}`,E(p(this.path)).then(e=>j(e,this.memfs))))}hostLog(t){if(!this.log)return;const e=`${P}>${u} `;this.stdout(`${e}${t}`)}async hostLogAsync(t,e){const s=+new Date;this.hostLog(`${t}...`);const i=await e,n=+new Date;return this.log&&this.stdout(" done."),this.showTiming&&this.stdout(` ${_}(${n-s}ms)${u}
`),this.log&&this.stdout(`
`),i}async getModule(t){if(this.moduleCache[t])return this.moduleCache[t];const e=await this.hostLogAsync(`Fetching and compiling ${t}`,A(t));return this.moduleCache[t]=e,e}async compile(t){const e=t.input,s=t.code,i=t.obj,n=t.opt||"2";await this.ready,this.memfs.addFile(e,s);const h=await this.getModule(F(this.path));return await this.run(h,this.log,"clang","-cc1","-emit-obj",...T,"-O"+n,"-o",i,"-x","c++",e)}async link(t,e){const i="lib/wasm32-wasi",n=`${i}/crt1.o`;await this.ready;const h=await this.getModule(B(this.path));return await this.run(h,this.log,"wasm-ld","--no-threads","--export-dynamic","-z","stack-size=1048576",`-L${i}`,n,t,"-lc","-lc++","-lc++abi","-lcanvas","-o",e)}async run(t,e,...s){this.memfs.out=e,this.hostLog(`${s.join(" ")}
`);const i=+new Date,n=new O(t,this.memfs,s[0],...s.slice(1)),h=+new Date,a=await n.run(),m=+new Date;return this.log&&this.stdout(`
`),this.showTiming&&this.stdout(`${_}(${i-h}ms/${m-h}ms)${u}
`),a?n:null}async compileLinkRun(t){const e="test.cc",s="test.o",i="test.wasm";this.lastCode!==t&&(await this.compile({input:e,code:t,obj:s}),await this.link(s,i)),this.lastCode=t;const n=await this.hostLogAsync(`Compiling ${i}`,WebAssembly.compile(this.memfs.getFileContents(i)));return await this.run(n,!0,i)}}export{I as default};
